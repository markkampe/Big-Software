<html>
<head>
<title>Key Learning Objectives</title>
</head>

<body>
<center>
<h1> Key Learning Objectives</h1>
<h2> Instructor: Mark Kampe</h2>
</center>

<P>
This course is organized around a several dozen key learning objectives.
They include basic concepts, issues, notations, and techniques.
The lectures, exams and labs will be built around these.
<P>
<OL>
<LI> concepts
<P>
	You should be able to 
	define them, 
	discuss how they relate to one-another,
	give examples, recognize instances, and
	discuss their meanings.
<P>
<LI> issues
<P>
	You should be able to 
	discuss the considerations to be weighed, 
	recognize the situations where they are relevent,
	interpret the issues in the context of a particular problem,
	and make and justify decisions based on them.
<P>
<LI> representations
<P>
	You should understand the purposes and key elements of each.
	You should be able to present information in these forms.
	You should be able to 
	answer questions about systems described in these formats.
<P>
<LI> techniques
<P>
	You should be familiar with the purpose of 
	and steps in each technique,
	and the considerations that go into performing those
	steps correctly.
<P>
</OL>

<P>


<table align=center border cellspacing=0 cellpadding=5>

<tr>
  <th>Lecture</th>
  <th>Subject</th>
  <th>Concepts</th>
  <th>Issues</th>
  <th>Representations</th>
  <th>Techniques</th>
</tr>

<tr>
<td>1<td>Introduction
	<td>	
		scope of s/w engr<br>
		characteristics of s/w (vs h/w)<br>
		criticality of methodology
	     </td>
	<td> 
		challenges of building s/w<br>
		challenges of legacy s/w<br>
		why projects fail
	     </td>
	<td> </td>
	<td> 	
		</td>
</tr>

<tr>
<td>2<td>Basic Project Skills
	<td>
		configuration management<br>
		change control<br>
		version control<br>
		distributed version control<br>
		standard build environment<br>
		gate keeping<br>
	    </td>
	<td>
		problems of reproducability<br>
		goals of version control<br>
		centralized vs distributed<br>
		change control trade-offs<br>
		goals of build automation<br>
	    </td>
	<td>
		hierarchical workspaces<br>
	    </td>
	<td>
		work partitioning<br>
		work scheduling<br>
		time management<br>
		post mortems<br>
		base releases and branches<br>
		conflict management<br>
		git<br>
	    </td>
</tr>

<tr>
<td>3<td>S/W Process Models
	<td>
		s/w definition<br>
		s/w planning<br>
		s/w construction<br>
		s/w deployment<br>
		work products<br>
		phases, activities, tasks<br>
	    </td>
	<td>	value of check-lists<br>
		choosing the right model<br>
		Big Requirements Up Front?<br>
		managing concurrency<br>
		safe phase overlap<br>
		planned iteration<br>
	    </td>
	<td>
		waterfall model<br>
		incremental model<br>
		spiral model
	    </td>
	<td>
	    </td>
</tr>

<tr>
<td>4<td>Requirements
	<td>
		stake holder<br>
		types of requirements<br>
		requirements vs specifications<br>
		clarity<br>
		consistency<br>
		testability<br>
		traceability<br>
	    </td>
	<td>
		criticality of requirements<br>
		costs of early mistakes<br>
		requirements stablility<br>
		requirements problems<br>
		scope creep<br>
	    </td>
	<td>
		requirement specification
	    </td>
	<td>
		surveys<br>
		reqts elicitation<br>
		reqts validation<br>
		reqts prioritization<br>
	    </td>
</tr>


<tr>
<td>5<td>Users, <br>Roles,<br> Use Cases</td>
	<td>
		role<br>
		scenario<br>
		use case (vs specification)<br>
		behavioral requirements<br>
	    </td>
	<td>
		good user classifications<br>
		understanding users/needs<br>
		why a graphical language<br>
		why a standard language<br>
	    </td>
	<td>
		user story cards<br>
		UML use case diagrams<br>
		UML activity diagrams<br>
		UML state diagrams<br>
	    </td>
	<td>
		user characterization<br>
		scenario development<br>
		task analysis<br>
	    </td>
	<td>
</tr>

<tr>
<td>6<td>Quality<br>Quality Assurance<br>
	<td>
		dimensions of quality<br>
		Q/A roles & activities<br>
		process assurance<br>
		process improvement<br>
	    </td>
	<td>
		testing vs Q/A<br>
		costs of defects<br>
		defect amplification<br>
		efficacy of Q/A techniques<br>
		when to do Q/A<br>
	    </td>
	<td>
	    </td>
	<td>
		defect removal techniques<br>
	    </td>
</tr>

<tr><td>7
	<td>System Models<br>and Modeling</td>
	<td>
		UML<br>
		system views<br>
		descriptive vs analytical models<br>
		queueing models<br>
		markov models<br>
		discrete event simulation<br>
	    </td>
	<td>
		reasons to model<br>
		reasons to prototype<br>
		agile modeling principles<br>
		model life span<br>
		choice of model type<br>
		choice of model representation<br>
	    </td>
	<td>
		component digrm<br>
		deployment digrm<br>
		architectural diagrams<br>
	    </td>
	<td>
		mathematical models<br>
		U/I prototypes<br>
		mechanism prototypes<br>
		proof-of-concept
	    </td>
</tr>


<tr>
<td>8<td>Architecture<br>(what)
	<td>	hierarchies of design<br>
		architecture (vs design)<br>
		modularity<br>
		information hiding<br>
		cohesion<br>
		complexity/simplicity<br>
		elegance<br>
		testability<br>
	    </td>
	<td>	
		criticality of architecture<br>
		scope of architecture<br>
		elements of good design<br>
		appropriate abstraction<br>
		criticality of interfaces<br>
		interface stability<br>
		mechanism/policy separation<br>
	    </td>
	<td>
	    </td>
	<td>	
		managing complexity<br>
	    </td>
</tr>

<tr>
<td>9<td>Architecture<br>(how)
	<td>	
		nature of design process<br>
		extensibility<br>
		portability<br>
	    </td>
	<td>
		anticipating change<br>
		designing for change<br>
		solving hard problems<br>
		anti-architectural forces<br>
		intuitive objects<br>
		why design is difficult<br>
	    </td>
	<td>
	    </td>
	<td>	
		domain object analysis<br>
		top-down design<br>
		bottom-up design<br>
		evaluating an architecture<br>
	    </td>
</tr>


<tr>
<td>10<td>Design Reviews</td>
	<td>
		reviews<br>
		walk-throughs<br>
	    </td>
	<td>
		relative costs of approaches<br>
		effectiveness of approaches<br>
		problems and solutions<br>
		vs. pair programming<br>
	    </td>
	<td>
	    </td>
	<td>
		review roles<br>
		review prep<br>
		review activities<br>
		review reports
	    </td>
</tr>

<td>11<td>U/I Design
	<td>
		Content Architecture
	    </td>
	<td>
		principles of UI design<br>
		examples: game usability<br>
		web UIs vs GUIs<br>
		principles of CLI design<br>
	    </td>
	<td>
		web site mapping<br>
	    </td>
	<td>
		usability testing<br>
		UI design process
	    </td>
</tr>


<tr>
<td>12<td>Class Design
	<td>
		component<br>
		specifications<br>
		classes<br>
		class associations<br>
		class dependencies<br>
		packages<br>
	    </td>
	<td>
		reasons to define classes<br>
		Liskov Substitution Principle<br>
		Dependency Inversion Principle<br>
		Release/Requse Equivalency Principle<br>
		Common Closure Principle<br>
	    </td>
	<td>
		class digrms<br>
		package digrms<br>
		object digrms<br>
	    </td>
	<td>
		OO-design<br>
		classes in non-OO languages<br>
	    </td>

</tr>

<tr>
<td>13<td>Routine and Algorithm Design<br>
	<td>
		macros & inlines
	    </td>
	<td>
		reasons to define routines<br>
		routine design principles<br>
		appropriate macro use<br>
		routine names<br>
		routine length<br>
		defining parameters<br>
		functions vs procedures<br>
	    </td>
	<td>
		pseudo-code<br>
		swim-lane digrms<br>
		UML sequence digrms<br>
		tabular designs<br>
	    </td>
	<td>
		developing routine design<br>
		program into your language<br>
	    </td>

</tr>

<tr>
<td>14<td>Design Patterns</td>
	<td>
		object abstraction<br>
		flow control patterns<br>
		concurrency patterns<br>
	    </td>
	<td>
	    </td>
	<td>
	    </td>
	<td>
		architectural design patterns (pipe/filter, layered, repositories, client-server)<br>
		class design patterns (singleton, bridge, adaptor, proxy, object pool)<br>
		algorithmic design patterns (iterator, observer, strategy, visitor, )<br>
	    </td>
</tr>

<tr>
<td>15<td>Test Cases and Testability
	<td>
		test cases & suites<br>
		black-box testing<br>
		white-box testing<br>
		code coverage<br>
		static complexity<br>
		testability<br>
	    </td>
	<td>
		limitations of testing<br>
		characteristics of a good test<br>
		black-box vs white-box<br>
		100% code coverage?<br>
		testing & risk<br>
		psychological issues<br>
	    </td>
	<td>
		test case specifications<br>
		test plan<br>
	    </td>
	<td>
		specfication-based testing<br>
		equivalence partitioning<br>
		boundary value analysis<br>
		orthogonal array testing<br>
		structural testing<br>
		data flow testing<br>
	    </td>
</tr>

<tr>
<td>16<td>Robustness
	<td>
		correctness, robustness<br>
		reliability, availability<br>
		defect, fault, error, failure<br>
		defensive programming<br>
	    </td>
	<td>
		causes of defects<br>
		causes of failures<br>
		error detection principles<br>
		
	    </td>
	<td>
		MTBF<br>
		FIT rates<br>
		fault handling reqts
	    </td>
	<td>
		assertions<br>
		fire-walls/barricades<br>
		defensive instrumentation<br>
		fail mode enumeration<br>
		error prioritization<br>
		error detection<br>
		error containment<br>
		error testing<br>
		error handling techniques<br>
		exceptions<br>
	    </td>
</tr>

<tr>
<td>17<td>Bugs & Debugging
	<td>
		back-traces<br>
		bug tracking system<br>
		bug report life cycle<br>
		bug fields<br>
		priority and severity<br>
	    </td>
	<td>
		minimal failure cases<br>
		good bug reports<br>
		hypothesis confirmation<br>
		similar bugs<br>
		psychological issues<br>
	    </td>
	<td>
		core dumps<br>
		stack traces<br>
		execution traces<br>
		bug reports<br>
	    </td>
	<td>
		bug triage<br>
		scientific debugging method<br>
		forensic analysis<br>
		diagnostic instrumentation<br>
		correct bug fixing<br>
		root-cause analysis
	    </td>
</tr>

<tr>
<td>18<td>Integration Strategy<br>Testing Methodology</td>
	<td>
		incremental integration<br>
		continuous integration<br>
		unit testing<br>
		regression testing<br>
		system testing<br>
		test harnesses<br>
		train model integration<br>
	    </td>
	<td>
		architecture & integration<br>
		development & integration<br>
		testing & integration<br>
		choosing integration strategy<br>
		daily builds & smoke tests<br>
		program vs routine testing<br>
		in-vivo vs in-vitro testing<br>
	    </td>
	<td>
	    </td>
	<td>
		test driven development<br>
		test harnesses<br>
	    </td>
</tr>

<tr>
<td>19<td>System Testing<br>Performance</td>
	<td>
		system testing<br>
		alpha testing<br>
		beta testing<br>
		Pareto principle<br>
		release phases<br>
	    </td>
	<td>
		unit vs system testing<br>
		testing and bug discovery<br>
		release criteria<br>
		performance principles<br>
		automated testing<br>
	    </td>
	<td>
		bug arrival rates<br>
		call counting<br>
		profiling<br>
	    </td>
	<td>
		scenario-based testing<br>
		load/stress testing<br>
		compatability/interoperability testing<br>
		load generation<br>
	    </td>
</tr>

<tr>
<td>20<td>Maintainability
	<td>
		elements of maintainability<br>
		elements of readability<br>
		elements of coding style<br>
		statement layout<br>
		code style as docn<br>
		style tools
	    </td>
	<td>
		comment types<br>
		when/how to comment<br>
		coding standards<br>
		module layout<br>
		indentation syles<br>
		commenting styles<br>
		external documentation<br>
	    </td>
	<td>
		javadoc<br>
		doxygen<br>
	    </td>
	<td>
	    </td>
</tr>


<tr>
<td>21<td>Agile Process
	<td>
		agile philosophy<br>
		Agile Aliance Principles<br>
		SCRUM sprint<br>
		product owner<br>
	    </td>
	<td>
		failings of formal process<br>
		Agile vs planned process?<br>
		how much process?<br>
		sprint cadence<br>
	    </td>
	<td>
		product backlog<br>
		sprint backlog<br>
	    </td>
		sprint planning<br>
		daily standup<br>
	<td>
	    </td>
</tr>

<tr>
<td>22<td>Productivity,<br>and Colaboration</td>
	<td>
		colaboration benefits<br>
		leadership<br>
		training<br>
		mentoring
	    </td>
	<td>
		contributors to productivity<br>
		range of individual productivity<br>
		challenges of pair programming<br>
		just in time s/w development<br>
		global s/w development<br>
	    </td>
	<td>
	    </td>
	<td>
		eXtreme Programming<br>
		Pair Programming<br>
		refactoring<br>
		collective code ownership<br>
	    </td>
</tr>



<tr>
<td>23<td>Estimation & Risk
	<td>
		size estimates<br>
		work estimates<br>
		Constructive Cost Model<br>
		types of risk<br>
	    </td>
	<td>
		estimation principles<br>
		productivity estimation<br>
		planning w/poor info<br>
		causes of technical risk<br>
		size vs productivity<br>
		size and activities<br>
	    </td>
	<td>
		SCRUM points<br>
		estimate confidence<br>
		risk assessment<br>
		risk management plan<br>
	    </td>
	<td>
		size estimation<br>
		backlog grooming<br>
		risk identification<br>
		risk mitigation<br>
		risk monitoring<br>
	    </td>
</tr>

<tr>
<td>24<td>Scheduling<br>Tracking<br>Management</td>
	<td>
		task dependencies<br>
		critical path<br>
		resource dependencies<br>
		critical resource<br>
		project management<br>
		sprint cadence<br>
	    </td>
	<td>
		SMART milestones<br>
		time vs. staffing<br>
		work vs. progress<br>
		quantifying progress<br>
		project warning signs<br>
		features/quality/schedule<br>
		causes of schedule slippage<br>
		dealing w/schedule slippage<br>
		adding more resources<br>
		communication vs proj size<br>
	    </td>
	<td>
		PERT Charts<br>
		Gantt charts<br>
		PNR effort/time curve<br>
		status reporting<br>
	    </td>
	<td>
		task breakdown<br>
		dependency analysis<br>
		project scheduling<br>
		backlog grooming<br>
		earned value analysis<br>
		sprint velocity<br>
		status collection<br>
		recognizing problems<br>
	    </td>
</tr>


<tr>
<td>25<td>Metrics and<br>Process Improvement<br>
	<strong>(spring only)</strong></td>
	<td>
		process improvement<br>
		ISO9000<br>
		Six Sigma<br>
		software metrics<br>
		process metrics<br>
	    </td>
	<td>
		good metrics<br>
		metrics gaming<br>
		metrics balancing<br>
		rational metrics use<br>
	    </td>
	<td>
		Capability Maturity Model<br>
	    </td>
	<td>
		continuous improvement<br>
		Best Practice Benchmarking<br>
	    </td>
</tr>

</table>


Last updated: July 2012

</body>
</html>
